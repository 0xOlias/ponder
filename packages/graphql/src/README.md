# Ponder GraphQL plugin details/implementation

This is an overview of how the plugin generates the final GraphQL schema, including resolver generation and interaction with the `EntityStore` from `@ponder/core`.

## Schema generation

Assume that the user has provided this `graphql.schema`:

```graphql
# schema.graphql

type Token @entity {
  id: ID!
  owner: Wallet!
}

type Wallet @entity {
  id: ID!
  tokens: [Token!]! @derivedFrom(field: "owner")
}
```

### Query object

This would result in a `Query` object with four fields; one singular and one plural field for each entity.

```graphql
enum OrderDirection {
  asc
  desc
}

type Query {
  token(id: ID!): Token
  tokens(
    first: Int
    skip: Int
    orderBy: String
    orderDirection: OrderDirection
    where: TokenFilter
  ): [Token!]!
  wallet(id: ID!): Wallet
  wallets(
    first: Int
    skip: Int
    orderBy: String
    orderDirection: OrderDirection
    where: WalletFilter
  ): [Wallet!]!
}
```

### Entity types

The entity types themselves also look slightly different from how they were defined in `schema.graphl`. Notably, the `Wallet.tokens` now accepts _the same arguments_ as `Query.tokens`.

```graphql
type Token {
  id: ID!
  wallet: Wallet!
}

type Wallet {
  id: ID!
  tokens(
    first: Int
    skip: Int
    orderBy: String
    orderDirection: OrderDirection
    where: TokenFilter
  ): [Token!]!
}
```

The difference is that the tokens returned by `Wallet.tokens` are already filtered to "belong" to the parent `Wallet` object. In SQL, this might look like adding `AND token.walletId === parentWalletId` to the query. This works recursively, but only edge at a time.

### Filter arguments

The filter arguments (`TokenFilter` and `WalletFilter` in this example) are autogenerated based on the entity type definition. Each field on the entity ends up adding between 4 and 20 fields to the filter argument for that entity. See `src/server/buildPluralField.ts` for specifics.

### Resolvers

The data that backs the GraphQL API has already been writted to the EntityStore. The EntityStore exposes some methods that make it easier to write our resolvers:

```ts
type Entity = Record<string, string | number>;

type EntityStore = {
  getEntity(entityName: string, id: string): Promise<Entity | null>;

  getEntities(entityName: string, filter?: EntityFilter): Promise<Entity[]>;

  getEntityDerivedField(
    entityName: string,
    id: string,
    derivedFieldName: string
  ): Promise<Entity[]>;
};
```

#### Resolving scalar fields

Scalars are easy: because those EntityStore methods always returns full objects for an entity, scalar fields are already present on resolved objects with the correct types.

#### Resolving relationship fields

Relationship types (like `owner: Wallet` on `Token`) are trickier. The objects returned by the EntityStore have a string ID for relationship fields, because that's how they are persisted. A naive solution here would be to write a resolver for any relationship field that looks like this:

```ts
// This is the resolver for the `Token.owner` field
const resolver = (parent, args, context) => {
  // parent is the Token object, which has the wallet ID as the "owner" field
  const relatedEntityId = parent["owner"];

  const wallet = await context.entityStore.getEntity("owner", relatedEntityId);

  return wallet;
};
```

This works, but it's an N+1. For a query like

```graphql
{
  tokens(first: 100) {
    id
    wallet
  }
}
```

there will be 101 database queries: one to fetch the first 100 tokens, then 100 more to get the wallet for each token.

We can do better. This approach relies on the GraphQL `context`, which is just a JavaScript object that persists across all resolvers that run over the course of a single query. We'll basically just use it as a key-value store that caches the result of calls we make to the EntityStore.

```ts
type GraphqlQueryContext = {
  entities: Record<
    string /* An entity name, e.g. Token */,
    Record<
      string /* The entity ID */,
      any /* The entity object itself (including the ID field) */
    >
  >;
};
```

In the plural resolver function, after getting the list of entities, we can call another function to "preload" the related entities for that set of IDs:

```ts
// This is the resolver for the `Query.tokens` field
const resolver = (_, args, context) => {
  // 1) Get the initial set of entites (query count: 1)
  const tokens = await entityStore.getEntities("token", args.filter);

  // 2) Now, we have all the tokens we want, let's preload all the related wallets. (query count: 2)
  const tokenIds = tokens.map((t) => t.id);
  const relatedWallets = await entityStore.getEntities(relatedEntityName, {
    id_in: tokenIds
  });

  // 3) And add them to the query context
  context.entities["wallet"] ||= {};
  relatedWallets.forEach((wallet) => {
    context.entities["wallet"][wallet.id] = wallet;
  });

  // Now, recursively apply steps 2 and 3 for all related fields present in the query.
  // Because these related fields CANNOT be filtered in any way at all, ONLY the
  // initial
};
```

Then, in the field resolver, we can check for a cache hit before requesting the data from the EntityStore:

```ts
// This is the resolver for the `Token.owner` field
const resolver = (parent, args, context) => {
  const walletId = parent["owner"];

  let wallet = context.entities["wallet"][walletId];
  if (!wallet) {
    wallet = await context.entityStore.getEntity("wallet", walletId);
  }

  return wallet;
};
```

#### Resolving derivedFrom fields

Derived types (like `tokens: [Token!]! @derivedFrom("owner")` on `Wallet`) are trickier.
